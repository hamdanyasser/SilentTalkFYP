# ============================================
# Logstash Pipeline Configuration
# SilentTalk Platform Logging
# ============================================

input {
  # TCP input for structured logs
  tcp {
    port => 5000
    codec => json
    type => "application"
  }

  # UDP input for syslog-style logs
  udp {
    port => 5000
    codec => json
    type => "application"
  }

  # Beats input (optional, for future use)
  # beats {
  #   port => 5044
  # }
}

filter {
  # Parse JSON if not already parsed
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
    }
  }

  # Add timestamp if not present
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }

  # Add service identification
  if ![service] {
    mutate {
      add_field => { "service" => "unknown" }
    }
  }

  # Parse log level
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }

  # Add environment
  mutate {
    add_field => { "environment" => "${ENVIRONMENT:development}" }
  }

  # Grok patterns for common log formats
  grok {
    match => {
      "message" => [
        "%{TIMESTAMP_ISO8601:log_timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}",
        "%{GREEDYDATA:log_message}"
      ]
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "port" ]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "silentstalk-logs-%{+YYYY.MM.dd}"
    manage_template => true
    template_name => "silentstalk-logs"
    template_overwrite => true
  }

  # Debug output to stdout (development only)
  if [@metadata][environment] == "development" {
    stdout {
      codec => rubydebug
    }
  }
}
